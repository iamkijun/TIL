# 파이썬

---

## day06, 7월 25일 월요일

---

## 신입 개발자가 필요한 역량

- 커뮤니케이션 역량
- 문제 인지 능력
- 블로그의 가장 마지막 글에 대한 질문(검증)
- 배우고자 하는 태도와 자세
- 성장 가능성 **(중요!)**

오늘 잘하는 개발자보다 내일 더 잘할 수 있는 개발자

주니어 개발자는 채용해서 배우는 사람.

- 태도/자세
- 끝까지 일을 마무리 할 수 있는 능력
- 나만의 최적화된 학습 방법
  - 주니어때부터 쌓여왔던 사람들은 신기술이 나왔을 때도 폭풍성장할 수 있다.

- '나'라는 사람에 대한 인지(나 사용법)

지금 잘하는 것을 기대하는 것이 아니라 잘하기 위해서 필요한 것을 질문할 수 있어야 한다.

내가 해결한 문제 중 가장 큰 것

개발 기술 스택은 엄청 중요하지 않다.

'해봤다'는 이력서에 무조건 삭제

개발은 결국 팀플레이, 내가 함께 일하고 싶은 팀원인가

**나 자신에 대해 알아가는 시간을 가지자...**



### 데이터 구조 활용

- 데이터 구조를 활용하기 위해서는 메서드(method)를 활용
  - 메서드는 클래스 내부에 정의한 함수, 사실상 함수 동일
  - 쉽게 설명하자면 객체의 기능(추후 객체 지향 프로그래밍에서 학습)
  - **데이터 구조.메서드()** 형태로 활용!
  - 주어.동사() 같은 느낌 ex) 교수.말하기()



### 문자열(String Type)

- 문자들의 나열

  - 모든 문자는 str 타입(변경 불가능한 immutable)

- 문자열 조회/탐색 및 검증 메서드

  - s.find(x) - x의 첫번째 위치 반환. **없으면 -1을 반환**
  - s.index(x) - x의 첫번째 위치를 반환. **없으면 오류 발생**
  - s.isalpha() - 알파벳 문자 여부(한글도)
  - s.isupper() - 대문자 여부
  - s.islower() - 소문자 여부
  - s.istitle() - 타이틀 형식 여부(맨 첫글자만 대문자)

- 문자열 관련 검증 메서드

  - Isdecimal() < isdigit() < isnumeric()

- 문자열 변경 메서드

  - s.replace(old, new[, count]) - 바꿀 대상 글자를 새로운 글자로 바꿔서 반환. 
    - count를 지정하면 해당 개수만큼만 시행
  - s.strip([chars]) - 공백이나 특정 문자를 제거
    - Strip 양쪽, lstrip 왼쪽, rstrip 오른쪽
  - s.split(sep = None, maxsplit = -1) - 공백이나 특정 문자를 기준으로 분리
  - 'seperator'.join([iterable]) 구분자로 iterable을 합침
  - s.capitalize() - 첫번째 글자를 대문자로 변경
  - s.title() - 띄어쓰기를 기준으로 첫글자는 대문자
  - s.upper() - 대문자로 변경
  - s.lower() - 소문자로 변경
  - s.swapcase - 대소문자 서로 변경

  

### 리스트(List)

- 어떠한 자료형도 저장 가능
- 가변 자료형
- L.append(x) - 리스트 마지막에 항목 x를 추가
- L.insert(i, x) - 리스트 인덱스 i에 항목 x를 추가
  - i가 리스트 길이보다 큰 경우 맨 뒤에 추가
- L.remove(x) - 리스트 가장 왼쪽에 있는 항목(첫번째) x를 제거
  - 항목이 존재하지 않을 경우 ValueError
- L.pop() - 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거
- L.extend(m) - 순회형 m의 모든 항목들의 리스트 끝에 추가
  - +=와 같은 기능
- L.index(x, start, end) - 가장 왼쪽에 있는 항목 x의 인덱스를 반환
- L.reverse() - 리스트를 거꾸로 정렬
  - 원본(L)이 수정됨
- L.sort() - 리스트를 정렬
  - 원본(L)이 수정됨
- L.count(x) - 리스틍에서 항목 x가 몇개 존재하는지 갯수를 반환



### 연산자(Operator)

- in / not in
- 산술연산자 (+)
- 반복연산자 (*)



### 셋(Set)

- 집합연산이 가능
- 순서가 없기때문에 **인덱스를 이용한 접근 불가능**
- s.copy() - 셋의 얕은 복사 본을 반환
- s.add(x) - x가 셋 s에 없다면 추가
- s.pop() - 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거
  - set이 비어있을 경우, Key Error
- s.remove(x) - 항목 x를 셋 s에서 삭제
  - 항목이 존재하지 않을 경우, Key Error
- s.discard(x) - 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제
  - 없어도 에러가 나지 않음
- s.update(t) - 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가
  - 없으면 에러
- s.clear() - 모든 항목을 제거
- s.isdisjoint(t) - 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True 반환(서로소)
- s.issubset(t) - s가 t의 하위 셋인경우 True 반환
- s.issuperset(t) - s가 t의 상위 셋인경우 True 반환



### 딕셔너리(Dictionary)

- d.keys() - d의 모든 키를 담은 뷰 반환
- d.values(). - d의 모든 값을 담은 뷰
- d.items() - d의 모든 키-값 쌍을 담은 뷰를 반환
- d.get(k) - 키 k의 값을 반환하는데, 키 k가 딕셔너리에 없을 경우 None을 반환
- d.get(k, v) - 키 k의 값을 반환하는데, 키 k가 딕셔너리에 없을 경우 v를 반환
- d.pop(k) - 키 k의 값을 반환하고 k인 항목을 딕셔너리 ddㅔ서 삭제하는데 키 k가 딕셔너리에 없을 경우 KeyError를 발생
- d.pop(k, v) - 키 k의 값을 반환하고 k인 항목을 딕셔너리 ddㅔ서 삭제하는데, 키 k가 딕셔너리에 없을 경우 v를 반환
- d.update([other]) - 딕셔너리 d의 값을 매핑하여 업데이트



## 복사방법

- 할당(Assignment)
  - 대입 연산자 (=)
    - 값을 복사하는게 아니라 사물함의 주소를 복사
- 얕은 복사(Shallow copy)
  - Slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사
  - 복사하는 리스트의 원소가 주소를 참조하는 경우, 할당
- 깊은 복사
  - Import copy
  - Copy.deepcopy(a)